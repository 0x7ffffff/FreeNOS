[first]

* Let fs do pm->getID() to avoid race condition in mapping the process table?
    --> or let MM have the fs block until the pm maps the table right.

* procfs/ps: we need to map the kernel process table *readonly* into virtual memory

    --> this means effectively mapping kernel heap r/o, and returning a pointer
        to Process::procs.
	
    --> procfs (inside FileSystemServer), exports the process table to userspace :)
	(including kernel's)

* why not fill SELF in ::byID()!!! (so we can remove ugly code in api/*)

* shared memory @ memoryserver: let process server + filesystem server map the
  userprocess table.

* Setup initial NetworkServer (map userprocess table also)

* libposix: open(), read(), write(), close()

    --> map read only the user process table, to select the correct server

* /srv/storage/ram -> register to FileSystemServer

* Ext2FileSystem in FileSystemServer

* /dev/tty0-8 in /dev!!!!!

    --> shell moet deze openen, de servers gebruiken /dev/log oid.

* Faults -> process manager must receive the IRQ message!
    --> e.g. use faultPID or so??? (may be configurable in boot.conf)

* remove IRQ hooks in ~x86Process().
    --> simply keep a list with the copy of InterruptHook in each Process...
	--> Maybe also output this in ProcessInfo! :)

* Nicer /bin/sh:
    --> BACKSPACE should be supported. (low prio)
    --> ShellCommand class, and allow it to be derived. (high prio)
	--> INIT's!!! --> libcrt should support this too ofcourse.

* libparse, map which defines which priviledges each server/driver has...
    --> including phys -> virtual memory maps, I/O ports, IPC from/to permissions etc.
    --> just a simple configuration file should be sufficient

[bugs]
* fix Assert.h
* "Cursor pointer" in the VGA screen isn't updated...
* MemoryServer::doGrow() allocated a whole page, if e.g. only 1 byte is requested...
* fix parallel make (LD of the kernel that is, which races against $(subdirs)!)

[libraries]
* libc: %NUMs formats support

[programs]

[servers]
* /srv/storage, with a ramdisk and scsi (lsi's)
    --> Test it using, e.g. a dosfs dump of the project root
* /srv/filesystem, simple dosfs first
* /srv/memory: per process virtual memory stats.
    --> PROCESS_FOOTPRINT on initialization
    --> Use modEnd-modStart to calculate addition number of pages for boot modules
    --> then, for each MemoryMessage, just add it to the counter! :)

* Reincarnation server, a la minix 3.
* Inet server.
* Terminal server: make sure to have a something like: Vector<Terminal>, using ProcessID as index?
    --> so, this way, also a pseudo terminal, like for SSH, can work! :)

[sources]
* Perhaps, find a clean way to build libc and libposix using gcc and .c, instead of g++ and .cpp
    --> maybe, an extern C function in C++, which then can be used from pure C code, to send
        IPC messages...
* /boot directory, containing the grub.conf (instead of inside image.mk)
* Automatic copying of every file in the project to boot.iso!
* SVN's $headURL inside debug()?
* use #define ArchXXX etc
* void Memory::releasePhysical(Address addr)  <--- include size here?
* Don't send MemoryError, but just send an value from <Error.h>! :)

[kernel]
* perhaps we should allow multiple messages to be fetched in IPCMessage()! (speed++)
* Improve scheduler: don't put a Process on the queue if it isn't Ready!
    --> Also, fix the timer interval to switch processes --> currently a bit too fast...?
    --> Can we actually put the scheduler in userspace? Maybe a task gate? Is this slow?
* how to IPC using CPU registers only?
* SMP support!
