[DEFERRED]
++ FIX: Keyboard controller: real hardware, and in Virtualbox, doesn't respond! (keymapping problem?)
    --> THE PROBLEM IS THE COM1 PORT!!!!!!!
	--> DETECT IT PROPERLY

--> fix Assert.h
    --> we COULD map page tables + dirs READONLY in every proces.. this way, assertRead/Write is very
        efficient!!! (define inline/macros in arch/ for this)
	--> the same *COULD* be done for remotes, but be VERY carefull (NOT r/w too).
	--> /proc/maps!	
    --> perhaps, memory server can then do more management of virtual memory?

++ Improve IPC performance!!!
    --> Don't use the heap
    --> IPC via registers (avoid memory checking)
    --> benchmark!!!
    --> optimize x86Memory::*(); try to avoid mapRemote() if possible!!!

--> PoolAllocator: make sure minimize wasted space for large chunks: penatilize
    a bit for larger blocks, e.g. don't allocate 64 times 4096, but e.g. only 8 or 32 times 4096 or so.

--> We could merge the two mapVirtual() overloads into one, then check for p == this :)

--> fixup all posix library function documentation!!!

--> fixup libc --> divide the functions into seperate files, so
		   we can provide man pages like so too (like *BSD does)

[first]

--> VFS: FileCache.entries and Directory.entries are duplicate!!!
    --> should design this in a better way!


[5] --> ram filesystem, make sure we can read/write files right.

    ++ CreateFile:
	- regular,
	- directory
	++ device files
    
    --> put argv string pointer in %eax!!! (then copy in _entry)
	--> environment will eventually also be in there ;)
	
	--> Better: just copy it on the esp3 stack!!!
	    --> and use libparse for create an argv[] :)
	    --> then automatically, argv/env will be random :)
	    --> maybe, we shouldn't support the envp argument... only just getenv() :)
	
	--> libparse for this too.

	--> then, we can just fill in the mountpoint in grub.conf! :)

 --> How are we going to let filesystems know, which mountpoint to use?
         argv[1] seems most appropriate, but then again, how can we set argc/argv
	 for the boot modules?
	 
	    --> Use GRUB's boot module line, then parse it into argc/argv! :)
		--> most probably, we have to push it on the user stack... then let _entry() find it?

    --> Let VFS stat() the file!!!
	--> perform auth checks aswell ;D
	--> also implement it in libposix meanwhile :)

    --> make VFS aware of character/block files!!!
	--> then put them in '/dev' on the ram file system!!!
		
[6] --> Terminals! Mknod to /dev/tty0..7
	--> character device for this :)
	    --> try to use libteken.
	    --> use PID as major
	        use TermID as minor

--> just create e.g. /dev/serial0 for the serial port?
    --> run it as a different server i think, maybe /srv/serial
    
    --> if we have the main() argc/argv thingies, we could do configure
        the boot modules to use /dev/serial0 as the system console! :)

[8] --> make a /dev/random! ^.^
    --> e.g. RDTSC, IRQ's etc.

[9] --> libteken voor de terminal server!!!
[10] -->  Nicer /bin/sh:
        --> BACKSPACE should be supported. (low prio)
[11] --> remove IRQ hooks in ~x86Process(). Also, cleanup pending messages?
     --> simply keep a list with the copy of InterruptHook in each Process...
	--> Maybe also output this in ProcessInfo! :)
[12] --> Implement the notion of "current directory" in VirtualFileSystem.

[second]

    --> VFS should I/O with filesystem servers asynchroneously (i.e. no SendReceive!!!)
	--> have somekind of request queue for each mountpoint then.
    
[13] --> Faults -> process manager must receive the Fault message!
	--> e.g. use faultPID or so???
[15] --> Don't use ugly unions!!! Perhapse we can modify ::run() to customize
	 messages even more for handlers!
  
	  --> Better: just use FileMessage as a base class, derive the others :) (simple, works with current IPCServer too! :)
  
	    FileReadMessage  ] FileIOMessage
	    FileWriteMessage ]
	    FileCloseMessage ...

[16] --> /srv/storage/ram -> register to FileSystemServer
[17] --> Ext2FileSystem
[18] --> Let init drop it's priviledges (syscalls, ipc, etc)
[19] --> VMCtl() : maybe pass two Address pointers!!! Then write the actual used paddr + vaddr there!!!
[20] --> kernel messages/logging...

[bugs]
* Running 'ps' a couple of times, reveales a memory leak somewhere... (memstat shows this)
* "Cursor pointer" in the VGA screen isn't updated...
* MemoryServer::doGrow() allocated a whole page, if e.g. only 1 byte is requested...
* fix parallel make (LD of the kernel that is, which races against $(subdirs)!)

[libraries]
* libc: %NUMs formats support
* libparse: generic parser library, usefull for the Shell too! :)

[programs]
* Random stack, heap and program text!!!
* We DON'T want setuid/setgid bits! (and we really don't need them either).

[servers]
* /srv/storage, with a ramdisk and scsi (lsi's)
    --> Test it using, e.g. a dosfs dump of the project root
* /srv/filesystem, simple dosfs first
* /srv/memory: per process virtual memory stats.
    --> PROCESS_FOOTPRINT on initialization
    --> Use modEnd-modStart to calculate addition number of pages for boot modules
    --> then, for each MemoryMessage, just add it to the counter! :)
* Login server: allocate a pseudo tty? 
* Reincarnation server, a la minix 3.
* Inet server.

[sources]
* Perhaps, find a clean way to build libc and libposix using gcc and .c, instead of g++ and .cpp
    --> maybe, an extern C function in C++, which then can be used from pure C code, to send IPC messages...
* /boot directory, containing the grub.conf (instead of inside image.mk)
* Automatic copying of every file in the project to boot.iso!
* SVN's $headURL inside debug()?
* use #define ArchXXX etc
* void Memory::releasePhysical(Address addr)  <--- include size here?
* FooMessage.doBar() wrapper functions?

[kernel]
* perhaps we should allow multiple messages to be fetched in IPCMessage()! (speed++)
* Improve scheduler: don't put a Process on the queue if it isn't Ready!
    --> Also, fix the timer interval to switch processes --> currently a bit too fast...?
    --> Can we actually put the scheduler in userspace? Maybe a task gate? Is this slow?
* how to IPC using CPU registers only?
* SMP support!
